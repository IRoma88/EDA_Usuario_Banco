# -*- coding: utf-8 -*-
"""EDA_Usuario_Banco.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zzC__WKLgL7IYHjuyePNhj2r6chHwhPn

Una entidad bancaria contrata a una empresa de marketing encargada de contactar telef√≥nicamente a posibles clientes para determinar si est√°n interesados o no en adquirir un deposito a plazo fijo con el banco.

La informaci√≥n recolectada por la empresa de marketing se encuentra en un archivo CSV con 45215 filas y 17 columnas.

Cada registro contiene 16 caracter√≠sticas (las primeras 16 columnas) y una categor√≠a ("yes" o "no" dependiendo de si la persona est√° o no interesada en adquirir el producto).

# Librer√≠as

Importamos las librer√≠as b√°sicas para poder limpiar los datos de la tabla y hacerla m√°s f√°cil
"""

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns

"""# Importar y leer Dataset"""

df = pd.read_csv('dataset_banco.csv')
df.head()

df.columns

"""Vemos que las columnas est√°n en ingl√©s y que alguna columna no se sabe muy bien para qu√© est√°. Por lo que cambiaremos los nombres"""

df = df.rename(columns={
    'age': 'edad',
    'job': 'trabajo',
    'marital': 'estado_civil',
    'education': 'educacion',
    'default': 'morosidad',
    'balance': 'salario_anual',
    'housing': 'hipoteca',
    'loan': 'otro_credito',
    'contact': 'forma_contacto',
    'day': 'ultimo_dia_contacto',
    'month': 'ultimo_mes_contacto',
    'duration': 'duracion_contacto',
    'campaign': 'veces_contactadas',
    'pdays': 'pdays',
    'previous': 'previous',
    'poutcome': 'intentos',
    'y': 'prediccion'
})

df.head()

"""# Limpieza de Datos

Vamos a limpiar datos.
"""

df.info()

df.isnull().sum()

(df == 'unknown').sum().sum()

df['forma_contacto'].nunique()

df['forma_contacto'].value_counts()

df['intentos'].nunique()

df['intentos'].value_counts()

df['estado_civil'].value_counts()

"""Hay pocos datos nulos, pero muchos "unknown" en columnas que son poco relevantes para el resultado final. Las borramos. Tambi√©n nos aseguramos de que no se duplican los nombres como "divorced" "div." etc, que son lo mismo"""

df.columns = df.columns.str.lower()
df.dropna(inplace=True)
df.drop_duplicates(inplace=True)
df.isnull().sum()

df.head()

df = df.drop(columns=["forma_contacto", "duracion_contacto", "veces_contactadas", "pdays", "previous", "intentos"])

print("M√≠nimos de cada columna:")
print(df.min())

print("M√°ximos de cada columna:")
print(df.max())

"""edad                        776..... Claramente es un error, por lo que limitamos la edad a 90 a√±os."""

df = df[df["edad"] <= 90].copy()
df.describe()

df.info()

print("estado_civil...... ", df.estado_civil.unique())
print("trabajo........ ", df.trabajo.unique())
print("educacion...... ", df.educacion.unique())
print("morosidad........ ", df.morosidad.unique())
print("hipoteca...... ", df.hipoteca.unique())
print("otro_credito...... ", df.otro_credito.unique())
print("ultimo_mes...... ", df.ultimo_mes_contacto.unique())
print("prediccion..... ", df.prediccion.unique())

"""Depuramos los datos duplicados de las columnas"""

#Estado civil
condiciones_1 = [
    df.estado_civil.str.lower().str.contains("marr"),
    df.estado_civil.str.lower().str.contains("sin"),
    df.estado_civil.str.lower().str.contains("div")
]

opciones = ["casado", "soltero", "divorciado"]

df["estado_civil"] = np.select(condiciones_1, opciones, "otro")

#Puesto trabajo
condicion_2 = [
    df.trabajo.str.lower().str.contains("mana"),
    df.trabajo.str.lower().str.contains("unkn"),
    df.trabajo.str.lower().str.contains("serv"),
    df.trabajo.str.lower().str.contains("self"),
    df.trabajo.str.lower().str.contains("reti")
]

opciones = ["jefatura", "no_sabe", "servicios", "autonomo", "jubilado"]

df["trabajo"] = np.select(condicion_2, opciones, "otro")

#Educacion
condicion_3 = [
    df.educacion.str.lower().str.contains("tert"),
    df.educacion.str.lower().str.contains("sec"),
    df.educacion.str.lower().str.contains("pri"),
    df.educacion.str.lower().str.contains("unkn")
]

opciones = ["terciario", "secundario", "primario", "no_sabe"]

df["educacion"] = np.select(condicion_3, opciones, "otro")

#Mas creditos
condicion_4 = [
    df.otro_credito.str.lower().str.contains("yes"),
    df.otro_credito.str.lower().str.contains("no")
]
opciones = ["yes", "no"]

df["otro_credito"] = np.select(condicion_4, opciones, "otro")

df.head()

print("estado_civil...... ", df.estado_civil.unique())
print("trabajo........ ", df.trabajo.unique())
print("educacion...... ", df.educacion.unique())
print("morosidad........ ", df.morosidad.unique())
print("hipoteca...... ", df.hipoteca.unique())
print("otro_credito...... ", df.otro_credito.unique())
print("ultimo_mes...... ", df.ultimo_mes_contacto.unique())
print("prediccion..... ", df.prediccion.unique())

print(df.estado_civil.value_counts())
print("..........")
print(df.trabajo.value_counts())
print("..........")
print(df.educacion.value_counts())
print("..........")
print(df.morosidad.value_counts())
print("..........")
print(df.hipoteca.value_counts())
print("..........")
print(df.otro_credito.value_counts())
print("..........")
print(df.ultimo_mes_contacto.value_counts())
print("..........")
print(df.prediccion.value_counts())

"""# Depurar para descartar los usuarios que no interesan"""

# Filtrar las filas donde "morosidad" es "s√≠"
morosos = df[df['morosidad'] == "yes"]

# Contar la cantidad de morosos por trabajo
conteo_trabajo = morosos["trabajo"].value_counts()

# Imprimir el trabajo m√°s com√∫n entre los morosos
print("Tipo de trabajo con m√°s morosos:")
print(conteo_trabajo)

# Imprimir el trabajo m√°s moroso
conteo_trabajo_mas_moroso = conteo_trabajo.idxmax()
print(f"\nEl trabajo con m√°s morosos es: {conteo_trabajo_mas_moroso}")

# Contar la cantidad de morosos por estado civil
conteo_estado_civil = morosos["estado_civil"].value_counts()

# Imprimir el estado civil m√°s com√∫n entre los morosos
print("Estado civil con m√°s morosos:")
print(conteo_estado_civil)

# Imprimir el estado civil m√°s moroso
estado_civil_mas_moroso = conteo_estado_civil.idxmax()
print(f"\nEl estado civil con m√°s morosos es: {estado_civil_mas_moroso}")

# Contar la cantidad de morosos por educacion
conteo_educacion = morosos["educacion"].value_counts()

# Imprimir el estado civil m√°s com√∫n entre los morosos
print("Educacion con m√°s morosos:")
print(conteo_educacion)

# Imprimir el estado civil m√°s moroso
educacion_mas_moroso = conteo_educacion.idxmax()
print(f"\nEl estado civil con m√°s morosos es: {educacion_mas_moroso}")

"""# Insights primarios

Tras depurar y organizar datos vemos que, los posibles clientes por datos totales de la tabla son en su mayor medida

1.  Casados
2.  En trabajos que no dicen
3.  En el sector secundario


En cuanto a los que no interesan como clientes por indice de morosidad destacan


1.   Casados
2.   No dicen su trabajo
3.   Sector secundario

Por lo tanto voy a contrastar los resultados de los morosos con los no morosos
"""

# Filtrar las filas donde "morosidad" es "no"
no_morosos = df[df['morosidad'] == "no"]

# Contar la cantidad de no_morosos por estado civil
conteo_estado_civil = no_morosos["estado_civil"].value_counts()

# Imprimir el estado civil mas com√∫n entre los no_morosos
print("Estado civil con m√°s morosos:")
print(conteo_estado_civil)

# Imprimir el estado civil sin morosidad
estado_civil_menos_moroso = conteo_estado_civil.idxmax()
print(f"\nEl estado civil con menos morosos es: {estado_civil_menos_moroso}")

# Contar la cantidad de no_morosos por educacion
conteo_educacion = no_morosos["educacion"].value_counts()

# Imprimir el estado civil mas com√∫n entre los no_morosos
print("Educacion sin morosidad:")
print(conteo_educacion)

# Imprimir el estado civil sin morosidad
educacion_menos_moroso = conteo_educacion.idxmax()
print(f"\nEl educacion sin morosidad es: {educacion_menos_moroso}")

# Contar la cantidad de no_morosos por trabajo
conteo_trabajo = no_morosos["trabajo"].value_counts()

# Imprimir el trabajo m√°s com√∫n entre no deudores
print("Tipo de trabajo sin morosidad:")
print(conteo_trabajo)

# Imprimir el trabajo sin deudores
conteo_trabajo_menos_moroso = conteo_trabajo.idxmax()
print(f"\nEl trabajo sin deudores es: {conteo_trabajo_menos_moroso}")

"""# Vemos en cuanto a los m√°s destacados tanto deudores como no:

1. **Clientes Casados**

*   27201 Clientes totales
    *   448 tienen deudas
    *   26753 no las tiene



2. **No dicen su trabajo**

*   27745 clientes
    *   517 tienen deudas
    *   26753 no las tiene


3. **Tienen estudios secundarios**

*   23189 clientes
    *   458 tienen deudas
    *   22731 no las tiene


Con esto vemos que hay muy poca gente que no devuelve los cr√©ditos

# Buscamos el candidato ideal para conceder un cr√©dito
"""

# Filtrar registros sin morosidad y con predicci√≥n positiva de adquirir el producto
no_morosos_que_aceptan = df[
    (df['morosidad'] == "no") &
    (df['prediccion'] == "yes")
]

# Seleccionar columnas relevantes para agrupar y contar combinaciones
columnas_agrupacion = [
    'edad', 'estado_civil', 'educacion', 'trabajo',
    'salario_anual', 'hipoteca', 'otro_credito', 'prediccion'
]

# Contar ocurrencias de cada combinaci√≥n de valores
conteo_total = no_morosos_que_aceptan[columnas_agrupacion].value_counts()

# Mostrar combinaciones ordenadas por frecuencia
print("üìä Combinaci√≥n m√°s com√∫n de atributos entre los que no tienen morosidad y aceptan el cr√©dito:")
print(conteo_total.head())  # Mostramos solo las 5 m√°s comunes (opcional)

# Obtener la combinaci√≥n m√°s frecuente
combinacion_mas_comun = conteo_total.idxmax()
print(f"\n‚úÖ La combinaci√≥n m√°s frecuente es:\n{combinacion_mas_comun}")

"""### **El cliente m√°s com√∫n que acepta el cr√©dito sin morosidad es:**
1. 54 a√±os
2. Casado
3. Trabaja en el sector secundario
4. No dice su trabajo
5. No dice su salario
6. No tiene hipoteca
7. No tiene otro cr√©dito

Eliminamos los deudores
"""

# Actualizar el DataFrame original eliminando las filas donde "morosidad" es "yes"
df = df[df['morosidad'] != "yes"]

#Todo gente que devuelve las deudas
df.head(10)

df.info()

cualitativas = ["trabajo", "estado_civil", "educacion", "hipoteca", "otro_credito", "prediccion"]
cuantitativas = ["edad", "salario_anual"]

"""# An√°lisis de datos con gr√°ficos "plt y sns"
"""

pip install funpymodeling

from funpymodeling.exploratory import freq_tbl
from funpymodeling.exploratory import profiling_num

fig, ax = plt.subplots(nrows=len(cualitativas), ncols=1, figsize=(10,45))
fig.subplots_adjust(hspace=0.5)

for i, col in enumerate(cualitativas):
    sns.countplot(x=col, data=df, ax=ax[i], order = df[col].value_counts().index)
    ax[i].set_title(col)
    ax[i].set_xticklabels(ax[i].get_xticklabels(),rotation=30)

sns.distplot(df['edad'], bins=20, label = f'Skewness (Simetr√≠a): {df["edad"].skew()}', kde=True)
plt.legend(loc = 'best')
plt.title('edad')

sns.distplot(df[df['salario_anual'] < df['salario_anual'].quantile(0.90)]['salario_anual'], bins=30, kde=True) #Eliminamos el 1% con balance m√°s alto para poder visualizar mejor
plt.title('Salario_anual')

df.describe()

"""Tras eliminar deudores y filtrar por edades deducimos que el perfil m√°s llamativo es (seg√∫n las gr√°ficas):

* Edad entre 30 y 50 a√±os y casado
* Trabaja en el sector secundario
* No dice su trabajo
* Salario por debajo de los 1500
* S√≠ tiene hipoteca
* No tiene otro cr√©dito

Para pr√≥ximas consultas, a√±adir **sexo** y **nivel educativo m√°s claro**

"""
